/*
 * Copyright (C) 2022 Indoc Research
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { v4 as uuidv4 } from 'uuid';
import { CancelTokenSource } from 'axios';
import _ from 'lodash';

/**
 * this class is to keep track of axios cancel source and we can cancel them later
 */
class AxiosCancelManager {
    constructor() {
        /**
         * @type {{sourceId:string,cancelSource:CancelTokenSource}[]}
         */
        this._cancelSources = [];
    }

    /**
     * add a cancel source, so that all axios request can be cancelled at the same time
     * @param {CancelTokenSource} cancelSource the axios cancel source with a cancel method to cancel tha axios request
     * @returns {string} a id to keep track of this cancel source
     */
    addCancelSource(cancelSource) {
        if (!_.isFunction(cancelSource?.cancel)) {
            throw new TypeError(`addCancelSource should take in axios cancel source as parameter`)
        }
        const sourceId = uuidv4();
        this._cancelSources.push({ sourceId, cancelSource });
        return sourceId;
    }

    /**
     * remove the axios cancel source once the request finish(either success or error). so, please DO remember to call this on axios promise .finally()
     * @param {string} sourceId the corresponding cancel source id generated by addCancelSource
     * @returns {boolean} if the removal succeeds or not
     */
    removeCancelSource(sourceId) {
        if (!_.isString(sourceId)) {
            throw new TypeError(`sourceId should be a string`)
        }
        const removedArr = _.remove(this._cancelSources, (item) => item === sourceId);
        return removedArr.length !== 0;
    }

    /**
     * cancel a single axios request
     * @param {string} sourceId the corresponding cancel source id generated by addCancelSource
     * @returns {boolean} whether the axios request is cancel and the source is removed
     */
    cancelAxios(sourceId) {
        if (!_.isString(sourceId)) {
            throw new TypeError(`sourceId should be a string`)
        }
        /**
         * @type {{sourceId:string,cancelSource:CancelTokenSource}}
         */
        const item = _.find(this._cancelSources,(item)=>item.sourceId===sourceId);
        if(!item){
            return false;
        }else{
            _.isFunction(item.cancelSource.cancel)&&item.cancelSource.cancel();
            return this.removeCancelSource(sourceId);
        }
    }

    /**
     * cancel all axios request
     */
    cancelAllAxios(){
        this._cancelSources.forEach(item=>{
            _.isFunction(item.cancelSource.cancel)&&item.cancelSource.cancel();
        });
        this._cancelSources = [];
    }
}

const axiosCancelManager = new AxiosCancelManager();

export {axiosCancelManager};